/*******************************************************************************
* CGoGN: Combinatorial and Geometric modeling with Generic N-dimensional Maps  *
* version 0.1                                                                  *
* Copyright (C) 2009-2012, IGG Team, LSIIT, University of Strasbourg           *
*                                                                              *
* This library is free software; you can redistribute it and/or modify it      *
* under the terms of the GNU Lesser General Public License as published by the *
* Free Software Foundation; either version 2.1 of the License, or (at your     *
* option) any later version.                                                   *
*                                                                              *
* This library is distributed in the hope that it will be useful, but WITHOUT  *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License  *
* for more details.                                                            *
*                                                                              *
* You should have received a copy of the GNU Lesser General Public License     *
* along with this library; if not, write to the Free Software Foundation,      *
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.           *
*                                                                              *
* Web site: http://cgogn.unistra.fr/                                           *
* Contact information: cgogn@unistra.fr                                        *
*                                                                              *
*******************************************************************************/

#include "Topology/generic/attributeHandler.h"
#include "Topology/generic/autoAttributeHandler.h"
#include "Topology/generic/traversorCell.h"
#include "Topology/generic/traversor2.h"
#include "Topology/generic/cellmarker.h"

#include "Utils/compress.h"

namespace CGoGN
{

namespace Algo
{

namespace Surface
{

namespace Export
{

template <typename PFP>
bool exportPLY(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename, bool binary)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;
	
	// open file
	std::ofstream out ;
	if (!binary)
		out.open(filename, std::ios::out) ;
	else
		out.open(filename, std::ios::out | std::ios::binary) ;

	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	unsigned int nbDarts = map.getNbDarts() ;
	std::vector<unsigned int> facesSize ;
	std::vector<std::vector<unsigned int> > facesIdx ;
	facesSize.reserve(nbDarts/3) ;
	facesIdx.reserve(nbDarts/3) ;
	std::map<unsigned int, unsigned int> vIndex ;
	unsigned int vCpt = 0 ;
	std::vector<unsigned int> vertices ;
	vertices.reserve(nbDarts/6) ;

	// Go over all faces
	CellMarker<VERTEX> markV(map) ;
	TraversorF<MAP> t(map) ;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> fidx ;
		fidx.reserve(8) ;
		unsigned int degree = 0 ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			++degree ;
			unsigned int vNum = map.template getEmbedding<VERTEX>(it) ;
			if(!markV.isMarked(it))
			{
				markV.mark(it) ;
				vIndex[vNum] = vCpt++ ;
				vertices.push_back(vNum) ;
			}
			fidx.push_back(vIndex[vNum]) ;
		}
		facesSize.push_back(degree) ;
		facesIdx.push_back(fidx) ;
	}

	// Start writing the file
	out << "ply" << std::endl ;
	// ascii or binary
	if (!binary)
		out << "format ascii 1.0" << std::endl ;
	else
	{	// test endianness
		union
		{
		    uint32_t i ;
		    char c[4] ;
		} bint = {0x01020304} ;
		if (bint.c[0] == 1) // big endian
			out << "format binary_big_endian 1.0" << std::endl ;
		else
			out << "format binary_little_endian 1.0" << std::endl ;
	}

	out << "comment File generated by the CGoGN library" << std::endl ;
	out << "comment See : http://cgogn.unistra.fr/" << std::endl ;
	out << "comment or contact : cgogn@unistra.fr" << std::endl ;
	// Vertex elements
	out << "element vertex " << vertices.size() << std::endl ;
	// Position property
	if (position.isValid())
	{
		out << "property " << nameOfTypePly(position[0][0]) << " x" << std::endl ;
		out << "property " << nameOfTypePly(position[0][1]) << " y" << std::endl ;
		out << "property " << nameOfTypePly(position[0][2]) << " z" << std::endl ;
	}
	// Face element
	out << "element face " << facesSize.size() << std::endl ;
	out << "property list uint8 uint" << 8 * sizeof(facesIdx[0][0]) << " vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	if (!binary)	// ascii
	{
		// ascii vertices
		for(unsigned int i = 0; i < vertices.size(); ++i)
			out << position[vertices[i]] << std::endl ;

		// ascii faces
		for(unsigned int i = 0; i < facesSize.size(); ++i)
		{
			out << facesSize[i] ;
			for(unsigned int j = 0; j < facesIdx[i].size(); ++j)
				out << " " << facesIdx[i][j] ;
			out << std::endl ;
		}
	}
	else // binary
	{
		// binary vertices
		for(unsigned int i = 0; i < vertices.size(); ++i)
		{
			Geom::Vec3f v = position[vertices[i]] ;
			out.write((char*)(&(v[0])), sizeof(v)) ;
		}

		// binary faces
		for(unsigned int i = 0; i < facesSize.size(); ++i)
		{
			unsigned char nbe = facesSize[i] ;
			out.write((char*)(&nbe), sizeof(unsigned char)) ;
			out.write((char*)(&(facesIdx[i][0])), facesSize[i] * sizeof(facesIdx[i][0])) ;
		}
	}

	out.close() ;

	return true ;
}

template <typename PFP>
bool exportPLYnew(typename PFP::MAP& map, const std::vector<VertexAttribute<typename PFP::VEC3>*>& attributeHandlers, const char* filename, bool binary)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	// open file
	std::ofstream out ;
	if (!binary)
		out.open(filename, std::ios::out) ;
	else
		out.open(filename, std::ios::out | std::ios::binary) ;

	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	unsigned int nbDarts = map.getNbDarts() ;
	std::vector<unsigned int> facesSize ;
	std::vector<std::vector<unsigned int> > facesIdx ;
	facesSize.reserve(nbDarts/3) ;
	facesIdx.reserve(nbDarts/3) ;
	std::map<unsigned int, unsigned int> vIndex ;
	unsigned int vCpt = 0 ;
	std::vector<unsigned int> vertices ;
	vertices.reserve(nbDarts/6) ;

	// Go over all faces
	CellMarker<VERTEX> markV(map) ;
	TraversorF<MAP> t(map) ;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> fidx ;
		fidx.reserve(8) ;
		unsigned int degree = 0 ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			++degree ;
			unsigned int vNum = map.template getEmbedding<VERTEX>(it) ;
			if(!markV.isMarked(it))
			{
				markV.mark(it) ;
				vIndex[vNum] = vCpt++ ;
				vertices.push_back(vNum) ;
			}
			fidx.push_back(vIndex[vNum]) ;
		}
		facesSize.push_back(degree) ;
		facesIdx.push_back(fidx) ;
	}

	// Start writing the file
	out << "ply" << std::endl ;
	// ascii or binary
	if (!binary)
		out << "format ascii 1.0" << std::endl ;
	else
	{	// test endianness
		union
		{
		    uint32_t i ;
		    char c[4] ;
		} bint = {0x01020304} ;
		if (bint.c[0] == 1) // big endian
			out << "format binary_big_endian 1.0" << std::endl ;
		else
			out << "format binary_little_endian 1.0" << std::endl ;
	}

	out << "comment File generated by the CGoGN library" << std::endl ;
	out << "comment See : http://cgogn.unistra.fr/" << std::endl ;
	out << "comment or contact : cgogn@unistra.fr" << std::endl ;
	// Vertex elements
	out << "element vertex " << vertices.size() << std::endl ;
	for (typename std::vector<VertexAttribute<typename PFP::VEC3>* >::const_iterator attrHandler = attributeHandlers.begin() ; attrHandler != attributeHandlers.end() ; ++attrHandler)
	{
		if ((*attrHandler)->isValid() && ((*attrHandler)->getOrbit() == VERTEX) )
		{
			if ((*attrHandler)->name().compare("position") == 0)  // Vertex position property
			{
				out << "property " << nameOfTypePly((*(*attrHandler))[0][0]) << " x" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][1]) << " y" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][2]) << " z" << std::endl ;
			}
			else if ((*attrHandler)->name().compare("normal") == 0)	// normal property
			{
				out << "property " << nameOfTypePly((*(*attrHandler))[0][0]) << " nx" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][1]) << " ny" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][2]) << " nz" << std::endl ;
			}
			else if ((*attrHandler)->name().compare("color") == 0)	// vertex color property
			{
				out << "property " << nameOfTypePly((*(*attrHandler))[0][0]) << " r" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][1]) << " g" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][2]) << " b" << std::endl ;
			}
			else // other vertex properties
			{
				out << "property " << nameOfTypePly((*(*attrHandler))[0][0]) << " " << (*attrHandler)->name() << "_0" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][1]) << " " << (*attrHandler)->name() << "_1" << std::endl ;
				out << "property " << nameOfTypePly((*(*attrHandler))[0][2]) << " " << (*attrHandler)->name() << "_2" << std::endl ;
			}
		}
	}

	// Face element
	out << "element face " << facesSize.size() << std::endl ;
	out << "property list uint8 " << nameOfTypePly(facesIdx[0][0]) << " vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	if (!binary)	// ascii
	{
		// ascii vertices
		for(unsigned int i = 0; i < vertices.size(); ++i)
		{
			for (typename std::vector<VertexAttribute<typename PFP::VEC3>* >::const_iterator attrHandler = attributeHandlers.begin() ; attrHandler != attributeHandlers.end() ; ++attrHandler)
				if ((*attrHandler)->isValid() && (*attrHandler)->getOrbit() == VERTEX)
					out << (*(*attrHandler))[vertices[i]] ;
			out << std::endl ;
		}

		// ascii faces
		for(unsigned int i = 0; i < facesSize.size(); ++i)
		{
			out << facesSize[i] ;
			for(unsigned int j = 0; j < facesIdx[i].size(); ++j)
				out << " " << facesIdx[i][j] ;
			out << std::endl ;
		}
	}
	else // binary
	{
		// binary vertices
		for(unsigned int i = 0; i < vertices.size(); ++i)
			for (typename std::vector<VertexAttribute<typename PFP::VEC3>*>::const_iterator attrHandler = attributeHandlers.begin() ; attrHandler != attributeHandlers.end() ; ++attrHandler)
				if ((*attrHandler)->isValid() && (*attrHandler)->getOrbit() == VERTEX)
				{
					const typename PFP::VEC3& v = (*(*attrHandler))[vertices[i]] ;
					out.write((char*)(&(v[0])), sizeof(v)) ;
				}

		// binary faces
		for(unsigned int i = 0; i < facesSize.size(); ++i)
		{
			uint8_t nbe = facesSize[i] ;
			out.write((char*)(&nbe), sizeof(uint8_t)) ;
			out.write((char*)(&(facesIdx[i][0])), facesSize[i] * sizeof(facesIdx[i][0])) ;
		}
	}

	out.close() ;

	return true ;
}

template <typename PFP>
bool exportOFF(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;
	
	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	unsigned int nbDarts = map.getNbDarts() ;
	std::vector<unsigned int> facesSize ;
	std::vector<std::vector<unsigned int> > facesIdx ;
	facesSize.reserve(nbDarts/3) ;
	facesIdx.reserve(nbDarts/3) ;
	std::map<unsigned int, unsigned int> vIndex ;
	unsigned int vCpt = 0 ;
	std::vector<unsigned int> vertices ;
	vertices.reserve(nbDarts/6) ;

	CellMarker<VERTEX> markV(map) ;
	TraversorF<MAP> t(map) ;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> fidx ;
		fidx.reserve(8) ;
		unsigned int degree = 0 ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			++degree ;
			unsigned int vNum = map.template getEmbedding<VERTEX>(it) ;
			if(!markV.isMarked(it))
			{
				markV.mark(it) ;
				vIndex[vNum] = vCpt++ ;
				vertices.push_back(vNum) ;
			}
			fidx.push_back(vIndex[vNum]) ;
		}
		facesSize.push_back(degree) ;
		facesIdx.push_back(fidx) ;
	}

	out << "OFF" << std::endl ;
	out << vertices.size() << " " << facesSize.size() << " " << 0 << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		const VEC3& v = position[vertices[i]] ;
		out << v[0] << " " << v[1] << " " << v[2] << std::endl ;
	}
	for(unsigned int i = 0; i < facesSize.size(); ++i)
	{
		out << facesSize[i] ;
		for(unsigned int j = 0; j < facesIdx[i].size(); ++j)
			out << " " << facesIdx[i][j] ;
		out << std::endl ;
	}

	out.close() ;
	return true ;
}
/*
template <typename PFP>
bool exportOBJ(typename PFP::MAP& map, const typename PFP::TVEC3& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	unsigned int nbDarts = map.getNbDarts() ;
	std::vector<unsigned int> facesSize ;
	std::vector<std::vector<unsigned int> > facesIdx ;
	facesSize.reserve(nbDarts/3) ;
	facesIdx.reserve(nbDarts/3) ;
	std::map<unsigned int, unsigned int> vIndex ;
	unsigned int vCpt = 0 ;
	std::vector<unsigned int> vertices ;
	vertices.reserve(nbDarts/6) ;

	CellMarker<VERTEX> markV(map) ;
	TraversorF<MAP> t(map) ;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> fidx ;
		fidx.reserve(8) ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			unsigned int vNum = map.getEmbedding(VERTEX, it) ;
			if(!markV.isMarked(it))
			{
				markV.mark(it) ;
				vIndex[vNum] = vCpt++ ;
				vertices.push_back(vNum) ;
			}
			fidx.push_back(vIndex[vNum]+1) ;
		}
		facesIdx.push_back(fidx) ;
	}

	out << "#OBJ - Export from CGoGN" << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		const VEC3& v = position[vertices[i]] ;
		out << "v " << v[0] << " " << v[1] << " " << v[2] << std::endl ;
	}

	out << std::endl;

	for(unsigned int i = 0; i < facesIdx.size(); ++i)
	{
		out << "f ";
		for(unsigned int j = 0; j < facesIdx[i].size(); ++j)
			out << " " << facesIdx[i][j] ;
		out << std::endl ;
	}

	out.close() ;
	return true ;
}

template <typename PFP>
bool exportPlyPTMgeneric(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;
	typedef typename PFP::REAL REAL;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	VertexAutoAttribute<unsigned int> tableVertLab(map);

	unsigned int nbDarts = map.getNbDarts() ;

	std::vector<unsigned int> vertices;
	std::vector<unsigned int> faces;

	vertices.reserve(nbDarts/5);	// TODO non optimal reservation
	faces.reserve(nbDarts/3);

	CellMarker<VERTEX> markV(map);
	TraversorF<MAP> t(map) ;
	unsigned int lab = 0;
	unsigned int nbf = 0;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> face ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			if (!markV.isMarked(it))
			{
				markV.mark(it);
				tableVertLab[it] = lab++;
				vertices.push_back(map.template getEmbedding<VERTEX>(it));
			}
			face.push_back(tableVertLab[it]);
		}

		faces.push_back(face.size()) ;
		for (unsigned int i = 0 ; i < face.size() ; ++i)
			faces.push_back(face.at(i)) ;

		++nbf;
	}

	VertexAttribute<VEC3> frame[3] ;
	VertexAttribute<VEC3> colorPTM[15] ;

	frame[0] = map.template getAttribute<VEC3>(VERTEX, "frame_T") ;
	frame[1] = map.template getAttribute<VEC3>(VERTEX, "frame_B") ;
	frame[2] = map.template getAttribute<VEC3>(VERTEX, "frame_N") ;
	for (unsigned int i = 0 ; i < 15 ; ++i)
	{
		std::stringstream name ;
		name << "colorPTM_a" << i ;
		colorPTM[i] = map.template getAttribute<VEC3>(VERTEX,name.str()) ;
	}
	const unsigned int nbCoefs = colorPTM[14].isValid() ? 15 : (colorPTM[9].isValid() ? 10 : 6) ;

	out << "ply" << std::endl ;
	out << "format ascii 1.0" << std::endl ;
	out << "comment ply PTM (K. Vanhoey generic format)" << std::endl ;
	out << "element vertex " << vertices.size() << std::endl ;
	out << "property float x" << std::endl ;
	out << "property float y" << std::endl ;
	out << "property float z" << std::endl ;
	out << "property float tx" << std::endl ;
	out << "property float ty" << std::endl ;
	out << "property float tz" << std::endl ;
	out << "property float bx" << std::endl ;
	out << "property float by" << std::endl ;
	out << "property float bz" << std::endl ;
	out << "property float nx" << std::endl ;
	out << "property float ny" << std::endl ;
	out << "property float nz" << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C0_a" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C1_a" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C2_a" << coefI << std::endl ;

	VertexAttribute<REAL> errL2 = map.template getAttribute<REAL>(VERTEX, "errL2") ;
	VertexAttribute<REAL> errLmax = map.template getAttribute<REAL>(VERTEX, "errLmax") ;
	VertexAttribute<REAL> stdDev = map.template getAttribute<REAL>(VERTEX, "stdDev") ;
	if (errL2.isValid())
		out << "property float errL2" << std::endl ;
	if (errLmax.isValid())
		out << "property float errLmax" << std::endl ;
	if (stdDev.isValid())
		out << "property float stdDev" << std::endl ;

	out << "element face " << nbf << std::endl ;
	out << "property list uchar int vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		unsigned int vi = vertices[i];
		 // position
		for(unsigned int coord = 0 ; coord < 3 ; ++coord)
			out << position[vi][coord] << " " ;
		 // frame
		for(unsigned int axis = 0 ; axis < 3 ; ++axis)
			for (unsigned int coord = 0 ; coord < 3 ; ++coord)
				out << frame[axis][vi][coord] << " " ;
		 // coefficients
		for (unsigned int channel = 0 ; channel < 3 ; ++channel)
			for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
				out << colorPTM[coefI][vi][channel] << " "  ;
		 // fitting errors (if any)
		if (errL2.isValid())
			out << errL2[vi] << " " ;
		if (errLmax.isValid())
			out << errLmax[vi] << " " ;
		if (stdDev.isValid())
			out << stdDev[vi] << " " ;
		out << std::endl ;
	}

	std::vector<unsigned int>::iterator it = faces.begin();
	while (it != faces.end())
	{
		unsigned int nbe = *it++;
		out << nbe ;
		for(unsigned int j = 0; j < nbe; ++j)
			out << " " << *it++;
		out << std::endl ;
	}

	out.close() ;
	return true ;
}
*/
/*
template <typename PFP>
bool exportPlySLFgeneric(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;
	typedef typename PFP::REAL REAL;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	AutoAttributeHandler<unsigned int> tableVertLab(map, VERTEX);

	unsigned int nbDarts = map.getNbDarts() ;

	std::vector<unsigned int> vertices;
	std::vector<unsigned int> faces;

	vertices.reserve(nbDarts/5);	// TODO non optimal reservation
	faces.reserve(nbDarts/3);

	CellMarker markV(map, VERTEX);
	TraversorF<MAP> t(map) ;
	unsigned int lab = 0;
	unsigned int nbf = 0;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> face ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			if (!markV.isMarked(it))
			{
				markV.mark(it);
				tableVertLab[it] = lab++;
				vertices.push_back(map.getEmbedding<VERTEX>(it));
			}
			face.push_back(tableVertLab[it]);
		}

		faces.push_back(face.size()) ;
		for (unsigned int i = 0 ; i < face.size() ; ++i)
			faces.push_back(face.at(i)) ;

		++nbf;
	}

	VertexAttribute<typename PFP::VEC3> frame[3] ;
	std::vector<TVEC3> coefs ;

	frame[0] = map.template getAttribute<VEC3>(VERTEX, "frame_T") ;
	frame[1] = map.template getAttribute<VEC3>(VERTEX, "frame_B") ;
	frame[2] = map.template getAttribute<VEC3>(VERTEX, "frame_N") ;

	unsigned int i = 0 ;
	do {
		std::stringstream name ;
		name << "SLFcoefs_" << i++ ;
		coefs.push_back(map.template getAttribute<VEC3>(VERTEX, name.str())) ;
	} while (coefs[i-1].isValid()) ;
	const unsigned int nbCoefs = i - 1 ; // last valid one is i-2

	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		assert(coefs[coefI].isValid()) ;

	std::string file(filename) ;
	size_t pos = file.rfind(".") ; // position of "." in filename
	std::string extension = file.substr(pos) ;

	out << "ply" << std::endl ;
	out << "format ascii 1.0" << std::endl ;
	out << "comment ply SLF (K. Vanhoey generic format): SLF_" << (((extension == ".plyPTMext") || extension == ".plyPTMextBin" ) ? "PTMext" : "SHreal") << std::endl ;
	out << "element vertex " << vertices.size() << std::endl ;
	out << "property float x" << std::endl ;
	out << "property float y" << std::endl ;
	out << "property float z" << std::endl ;
	out << "property float tx" << std::endl ;
	out << "property float ty" << std::endl ;
	out << "property float tz" << std::endl ;
	out << "property float bx" << std::endl ;
	out << "property float by" << std::endl ;
	out << "property float bz" << std::endl ;
	out << "property float nx" << std::endl ;
	out << "property float ny" << std::endl ;
	out << "property float nz" << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C0_" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C1_" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C2_" << coefI << std::endl ;

	out << "element face " << nbf << std::endl ;
	out << "property list uchar int vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		unsigned int vi = vertices[i];
		 // position
		for(unsigned int coord = 0 ; coord < 3 ; ++coord)
			out << position[vi][coord] << " " ;
		 // frame
		for(unsigned int axis = 0 ; axis < 3 ; ++axis)
			for (unsigned int coord = 0 ; coord < 3 ; ++coord)
				out << frame[axis][vi][coord] << " " ;
		 // coefficients
		for (unsigned int channel = 0 ; channel < 3 ; ++channel)
			for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
				out << coefs[coefI][vi][channel] << " "  ;

		out << std::endl ;
	}

	std::vector<unsigned int>::iterator it = faces.begin();
	while (it != faces.end())
	{
		unsigned int nbe = *it++;
		out << nbe ;
		for(unsigned int j = 0; j < nbe; ++j)
			out << " " << *it++;
		out << std::endl ;
	}

	out.close() ;
	return true ;
}

template <typename PFP>
bool exportPlySLFgenericBin(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;
	typedef typename PFP::REAL REAL;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	AutoAttributeHandler<unsigned int> tableVertLab(map, VERTEX);

	unsigned int nbDarts = map.getNbDarts() ;

	std::vector<unsigned int> vertices;
	std::vector<unsigned int> faces;

	vertices.reserve(nbDarts/5);	// TODO non optimal reservation
	faces.reserve(nbDarts/3);

	CellMarker markV(map, VERTEX);
	TraversorF<MAP> t(map) ;
	unsigned int lab = 0;
	unsigned int nbf = 0;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> face ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			if (!markV.isMarked(it))
			{
				markV.mark(it);
				tableVertLab[it] = lab++;
				vertices.push_back(map.getEmbedding<VERTEX>(it));
			}
			face.push_back(tableVertLab[it]);
		}

		faces.push_back(face.size()) ;
		for (unsigned int i = 0 ; i < face.size() ; ++i)
			faces.push_back(face.at(i)) ;

		++nbf;
	}

	TVEC3 frame[3] ;
	std::vector<TVEC3> coefs ;

	frame[0] = map.template getAttribute<VEC3>(VERTEX, "frame_T") ;
	frame[1] = map.template getAttribute<VEC3>(VERTEX, "frame_B") ;
	frame[2] = map.template getAttribute<VEC3>(VERTEX, "frame_N") ;

	unsigned int i = 0 ;
	do {
		std::stringstream name ;
		name << "SLFcoefs_" << i++ ;
		coefs.push_back(map.template getAttribute<VEC3>(VERTEX, name.str())) ;
	} while (coefs[i-1].isValid()) ;
	const unsigned int nbCoefs = i - 1 ; // last valid one is i-2

	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		assert(coefs[coefI].isValid()) ;

	std::string file(filename) ;
	size_t pos = file.rfind(".") ; // position of "." in filename
	std::string extension = file.substr(pos) ;

	out << "ply" << std::endl ;
	out << "format ascii 1.0" << std::endl ;
	out << "comment ply SLF (K. Vanhoey generic format): SLF_" << ((extension == ".plyPTMext") ? "PTMext" : "SHreal") << std::endl ;
	out << "element vertex " << vertices.size() << std::endl ;
	out << "property float x" << std::endl ;
	out << "property float y" << std::endl ;
	out << "property float z" << std::endl ;
	out << "property float tx" << std::endl ;
	out << "property float ty" << std::endl ;
	out << "property float tz" << std::endl ;
	out << "property float bx" << std::endl ;
	out << "property float by" << std::endl ;
	out << "property float bz" << std::endl ;
	out << "property float nx" << std::endl ;
	out << "property float ny" << std::endl ;
	out << "property float nz" << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C0_" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C1_" << coefI << std::endl ;
	for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
		out << "property float C2_" << coefI << std::endl ;

	out << "element face " << nbf << std::endl ;
	out << "property list uchar int vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		unsigned int vi = vertices[i];
		 // position
		for(unsigned int coord = 0 ; coord < 3 ; ++coord)
		{
			const float& floatofdouble = position[vi][coord] ;
			out.write((char*)(&floatofdouble), sizeof(float)) ;
		}
		 // frame
		for(unsigned int axis = 0 ; axis < 3 ; ++axis)
			for (unsigned int coord = 0 ; coord < 3 ; ++coord)
			{
				const float& floatofdouble = frame[axis][vi][coord] ;
				out.write((char*)(&floatofdouble), sizeof(float)) ;
			}
		 // coefficients
		for (unsigned int channel = 0 ; channel < 3 ; ++channel)
			for(unsigned int coefI = 0 ; coefI < nbCoefs ; ++coefI)
			{
				const float& floatofdouble = coefs[coefI][vi][channel] ;
				out.write((char*)(&floatofdouble), sizeof(float)) ;
			}
	}

	std::vector<unsigned int>::iterator it = faces.begin();
	while (it != faces.end())
	{
		unsigned int nbe = *it++;
		out.write((char*)&nbe, sizeof(unsigned int)) ;
		for(unsigned int j = 0; j < nbe; ++j)
		{
			unsigned int index = *it++ ;
			out.write((char*)(&index), sizeof(unsigned int)) ;
		}
	}

	out.close() ;
	return true ;
}

template <typename PFP>
bool exportPLYPTM(typename PFP::MAP& map, const char* filename, const VertexAttribute<typename PFP::VEC3>& position, const VertexAttribute<typename PFP::VEC3> frame[3], const VertexAttribute<typename PFP::VEC3> colorPTM[6])
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	VertexAutoAttribute<unsigned int> tableVertLab(map);

	unsigned int nbDarts = map.getNbDarts() ;

	std::vector<unsigned int> vertices;
	std::vector<unsigned int> faces;

	vertices.reserve(nbDarts/5);	// TODO non optimal reservation
	faces.reserve(nbDarts/3);

	CellMarker<VERTEX> markV(map);
	TraversorF<MAP> t(map) ;
	unsigned int lab = 0;
	unsigned int nbf = 0;
	for(Dart d = t.begin(); d != t.end(); d = t.next())
	{
		std::vector<unsigned int> face ;
		Traversor2FV<typename PFP::MAP> tfv(map, d) ;
		for(Dart it = tfv.begin(); it != tfv.end(); it = tfv.next())
		{
			if (!markV.isMarked(it))
			{
				markV.mark(it);
				tableVertLab[it] = lab++;
				vertices.push_back(map.template getEmbedding<VERTEX>(it));
			}
			face.push_back(tableVertLab[it]);
		}

		faces.push_back(face.size()) ;
		for (unsigned int i = 0 ; i < face.size() ; ++i)
			faces.push_back(face.at(i)) ;

		++nbf;
	}

	out << "ply" << std::endl ;
	out << "format ascii 1.0" << std::endl ;
	out << "comment ply PTM (F. Larue format)" << std::endl ;
	out << "element vertex " << vertices.size() << std::endl ;
	out << "property float x" << std::endl ;
	out << "property float y" << std::endl ;
	out << "property float z" << std::endl ;
	out << "property float tx" << std::endl ;
	out << "property float ty" << std::endl ;
	out << "property float tz" << std::endl ;
	out << "property float bx" << std::endl ;
	out << "property float by" << std::endl ;
	out << "property float bz" << std::endl ;
	out << "property float nx" << std::endl ;
	out << "property float ny" << std::endl ;
	out << "property float nz" << std::endl ;
	out << "property float L1_a" << std::endl ;
	out << "property float L1_b" << std::endl ;
	out << "property float L1_c" << std::endl ;
	out << "property float L1_d" << std::endl ;
	out << "property float L1_e" << std::endl ;
	out << "property float L1_f" << std::endl ;
	out << "property float L2_a" << std::endl ;
	out << "property float L2_b" << std::endl ;
	out << "property float L2_c" << std::endl ;
	out << "property float L2_d" << std::endl ;
	out << "property float L2_e" << std::endl ;
	out << "property float L2_f" << std::endl ;
	out << "property float L3_a" << std::endl ;
	out << "property float L3_b" << std::endl ;
	out << "property float L3_c" << std::endl ;
	out << "property float L3_d" << std::endl ;
	out << "property float L3_e" << std::endl ;
	out << "property float L3_f" << std::endl ;
	out << "element face " << nbf << std::endl ;
	out << "property list uchar int vertex_indices" << std::endl ;
	out << "end_header" << std::endl ;

	for(unsigned int i = 0; i < vertices.size(); ++i)
	{
		unsigned int vi = vertices[i];
		out << position[vi][0] << " " << position[vi][1] << " " << position[vi][2] << " " ;
		out << frame[0][vi][0] << " " << frame[0][vi][1] << " " << frame[0][vi][2] << " " ;
		out << frame[1][vi][0] << " " << frame[1][vi][1] << " " << frame[1][vi][2] << " " ;
		out << frame[2][vi][0] << " " << frame[2][vi][1] << " " << frame[2][vi][2] << " " ;
		out << colorPTM[0][vi][0] << " " << colorPTM[1][vi][0] << " " << colorPTM[2][vi][0] << " " << colorPTM[3][vi][0] << " " << colorPTM[4][vi][0] << " " << colorPTM[5][vi][0] <<" " ;
		out << colorPTM[0][vi][1] << " " << colorPTM[1][vi][1] << " " << colorPTM[2][vi][1] << " " << colorPTM[3][vi][1] << " " << colorPTM[4][vi][1] << " " << colorPTM[5][vi][1] <<" " ;
		out << colorPTM[0][vi][2] << " " << colorPTM[1][vi][2] << " " << colorPTM[2][vi][2] << " " << colorPTM[3][vi][2] << " " << colorPTM[4][vi][2] << " " << colorPTM[5][vi][2] << std::endl ;
	}

	std::vector<unsigned int>::iterator it = faces.begin();
	while (it != faces.end())
	{
		unsigned int nbe = *it++;
		out << nbe ;
		for(unsigned int j = 0; j < nbe; ++j)
			out << " " << *it++;
		out << std::endl ;
	}

	out.close() ;
	return true ;
}
*/

template <typename PFP>
bool exportChoupi(typename PFP::MAP& map, const AttributeHandler<typename PFP::VEC3, VERTEX>& position, const char* filename)
{
	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	std::ofstream out(filename, std::ios::out) ;
	if (!out.good())
	{
		CGoGNerr << "Unable to open file " << CGoGNendl ;
		return false ;
	}

	out << map.template getNbOrbits<VERTEX>() << " " << map.template getNbOrbits<EDGE>() << std::endl;

	TraversorV<typename PFP::MAP> travV(map);
	for(Dart dit = travV.begin() ; dit != travV.end() ; dit = travV.next())
	{
		out << map.template getEmbedding<VERTEX>(dit) << " " << position[dit] << std::endl;
	}

	TraversorE<typename PFP::MAP> travE(map);
	unsigned int indexE = 0;
	for(Dart dit = travE.begin() ; dit != travE.end() ; dit = travE.next())
	{
		out << indexE << "  " << map.template getEmbedding<VERTEX>(dit) << " " << map.template getEmbedding<VERTEX>(map.phi2(dit)) << std::endl;
		++indexE;
	}

	out.close() ;
	return true ;
}




template <typename PFP>
bool exportVTU(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	if (map.dimension() != 2)
	{
		CGoGNerr << "Surface::Export::exportVTU works only with map of dimension 2"<< CGoGNendl;
		return false;
	}

	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	// open file
	std::ofstream fout ;
	fout.open(filename, std::ios::out) ;

	if (!fout.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	VertexAutoAttribute<unsigned int> indices(map,"indices_vert");

	unsigned int count=0;
	for (unsigned int i = position.begin(); i != position.end(); position.next(i))
	{
		indices[i] = count++;
	}

	std::vector<unsigned int> triangles;
	std::vector<unsigned int> quads;
	std::vector<unsigned int> others;
	std::vector<unsigned int> others_begin;
	triangles.reserve(2048);
	quads.reserve(2048);
	others.reserve(2048);
	others_begin.reserve(2048);

	TraversorF<MAP> trav(map) ;
	for(Dart d = trav.begin(); d != trav.end(); d = trav.next())
	{
		unsigned int degree = map.faceDegree(d);
		Dart f=d;
		switch(degree)
		{
			case 3:
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]);
				break;
			case 4:
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]);
				break;

			default:
				others_begin.push_back(others.size());
				do
				{
					others.push_back(indices[f]); f = map.phi1(f);

				} while (f!=d);
				break;
		}
	}
	others_begin.push_back(others.size());

	unsigned int nbtotal = triangles.size()/3 + quads.size()/4 + others_begin.size()-1;

	fout << "<?xml version=\"1.0\"?>" << std::endl;
	fout << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"BigEndian\">" << std::endl;
	fout << "<UnstructuredGrid>" <<  std::endl;
	fout << "<Piece NumberOfPoints=\"" << position.nbElements() << "\" NumberOfCells=\""<< nbtotal << "\">" << std::endl;
	fout << "<Points>" << std::endl;
	fout << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = position.begin(); i != position.end(); position.next(i))
	{
		const VEC3& P = position[i];
		fout << P[0]<< " " << P[1]<< " " << P[2] << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "</Points>" << std::endl;
	fout << "<Cells>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"connectivity\" Format=\"ascii\">" << std::endl;

	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		fout << triangles[i]   << " " << triangles[i+1] << " " << triangles[i+2] << std::endl;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		fout << quads[i]   << " " << quads[i+1] << " " << quads[i+2] << " " << quads[i+3]<< std::endl;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int beg = others_begin[i-1];
		unsigned int end = others_begin[i];
		for (unsigned int j=beg; j<end; ++j)
		{
			fout <<  others[j] << " ";
		}
		fout << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"offsets\" Format=\"ascii\">" ;

	unsigned int offset = 0;
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		offset += 3;
		if (i%60 ==0)
			fout << std::endl;
		fout << " " << offset;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		offset += 4;
		if (i%80 ==0)
			fout << std::endl;
		fout << " "<< offset;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int length = others_begin[i] - others_begin[i-1];
		offset += length;
		if (i%20 ==0)
			fout << std::endl;
		fout << " "<< offset;
		fout << std::endl;
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"UInt8\" Name=\"types\" Format=\"ascii\">";
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		if (i%60 ==0)
			fout << std::endl;
		fout << " 5";
	}
	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		if (i%80 ==0)
			fout << std::endl;
		fout << " 9";
	}
	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		if (i%20 ==0)
			fout << std::endl;
		fout << " 7";
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "</Cells>" << std::endl;
	fout << "</Piece>" << std::endl;
	fout << "</UnstructuredGrid>" << std::endl;
	fout << "</VTKFile>" << std::endl;

	fout.close();
	return true;
}

template <typename PFP>
bool exportVTUBinary(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	if (map.dimension() != 2)
	{
		CGoGNerr << "Surface::Export::exportVTU works only with map of dimension 2"<< CGoGNendl;
		return false;
	}

	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	// open file
	std::ofstream fout ;
	fout.open(filename, std::ios_base::out | std::ios_base::trunc) ;

	if (!fout.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	VertexAutoAttribute<unsigned int> indices(map,"indices_vert");

	unsigned int count=0;
	for (unsigned int i = position.begin(); i != position.end(); position.next(i))
	{
		indices[i] = count++;
	}

	std::vector<unsigned int> triangles;
	std::vector<unsigned int> quads;
	std::vector<unsigned int> others;
	std::vector<unsigned int> others_begin;
	triangles.reserve(2048);
	quads.reserve(2048);
	others.reserve(2048);
	others_begin.reserve(2048);

	TraversorF<MAP> trav(map) ;
	for(Dart d = trav.begin(); d != trav.end(); d = trav.next())
	{
		unsigned int degree = map.faceDegree(d);
		Dart f=d;
		switch(degree)
		{
			case 3:
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]);
				break;
			case 4:
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]);
				break;

			default:
				others_begin.push_back(others.size());
				do
				{
					others.push_back(indices[f]); f = map.phi1(f);

				} while (f!=d);
				break;
		}
	}
	others_begin.push_back(others.size());

	unsigned int nbtotal = triangles.size()/3 + quads.size()/4 + others_begin.size()-1;

	fout << "<?xml version=\"1.0\"?>" << std::endl;
	fout << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << std::endl;
	fout << "<UnstructuredGrid>" <<  std::endl;
	fout << "<Piece NumberOfPoints=\"" << position.nbElements() << "\" NumberOfCells=\""<< nbtotal << "\">" << std::endl;
	fout << "<Points>" << std::endl;
	fout << "<DataArray type =\"Float32\" Name =\"Position\" NumberOfComponents =\"3\" format =\"appended\" offset =\"0\"/>"  << std::endl;

	unsigned int offsetAppend = position.nbElements() * 3 * sizeof(float) + sizeof(unsigned int);	// Data + sz of blk

	fout << "</Points>" << std::endl;

	fout << "<Cells>" << std::endl;

	std::vector<int> bufferInt;
	bufferInt.reserve(triangles.size()+quads.size()+others.size());

	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		bufferInt.push_back(triangles[i]);
		bufferInt.push_back(triangles[i+1]);
		bufferInt.push_back(triangles[i+2]);
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		bufferInt.push_back(quads[i]);
		bufferInt.push_back(quads[i+1]);
		bufferInt.push_back(quads[i+2]);
		bufferInt.push_back(quads[i+3]);
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int beg = others_begin[i-1];
		unsigned int end = others_begin[i];
		for (unsigned int j=beg; j<end; ++j)
			bufferInt.push_back(others[j]);
	}

	fout << "<DataArray type =\"Int32\" Name =\"connectivity\" format =\"appended\" offset =\""<<offsetAppend<<"\"/>"  << std::endl;
	offsetAppend +=bufferInt.size() * sizeof(unsigned int) + sizeof(unsigned int);

	fout << "<DataArray type =\"Int32\" Name =\"offsets\" format =\"appended\" offset =\""<<offsetAppend<<"\"/>"  << std::endl;
	offsetAppend += (triangles.size()/3 + quads.size()/4 + others_begin.size()-1) * sizeof(unsigned int) + sizeof(unsigned int);

	fout << "<DataArray type =\"UInt8\" Name =\"types\" format =\"appended\" offset =\""<<offsetAppend<<"\"/>"  << std::endl;
//	offsetAppend += (triangles.size() + quads.size() + others_begin.size()) * sizeof(unsigned char) + sizeof(unsigned int);

	fout << "</Cells>" << std::endl;

	fout << "</Piece>" << std::endl;
	fout << "</UnstructuredGrid>" << std::endl;
	fout << "<AppendedData encoding=\"raw\">" << std::endl << "_";

	fout.close();
	fout.open(filename, std::ios_base::binary | std::ios_base::ate | std::ios_base::app);

	unsigned int lengthBuff=0;
	// bufferize and save position
	{
		std::vector<VEC3> bufferV3;
		bufferV3.reserve(position.nbElements());
		for (unsigned int i = position.begin(); i != position.end(); position.next(i))
			bufferV3.push_back(position[i]);

		lengthBuff = bufferV3.size()*sizeof(VEC3);
		fout.write((char*)&lengthBuff,sizeof(unsigned int));
		fout.write((char*)&bufferV3[0],lengthBuff);
	}

	// save already buffrized indices of primitives
	lengthBuff = bufferInt.size()*sizeof(unsigned int);
	fout.write((char*)&lengthBuff,sizeof(unsigned int));
	fout.write((char*)&(bufferInt[0]),lengthBuff);


	// bufferize and save offsets of primitives
	bufferInt.clear();
	unsigned int offset = 0;
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		offset += 3;
		bufferInt.push_back(offset);
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		offset += 4;
		bufferInt.push_back(offset);
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int length = others_begin[i] - others_begin[i-1];
		offset += length;
		bufferInt.push_back(offset);
	}

	lengthBuff = bufferInt.size()*sizeof(unsigned int);
	fout.write((char*)&lengthBuff,sizeof(unsigned int));
	fout.write((char*)&(bufferInt[0]), lengthBuff);

	// bufferize and save types of primitives

	std::vector<unsigned char> bufferUC;
	bufferUC.reserve(triangles.size()/3 + quads.size()/4 + others_begin.size());

	for (unsigned int i=0; i<triangles.size(); i+=3)
		bufferUC.push_back((unsigned char)5);

	for (unsigned int i=0; i<quads.size(); i+=4)
		bufferUC.push_back((unsigned char)9);

	for (unsigned int i=1; i<others_begin.size(); ++i)
		bufferUC.push_back((unsigned char)7);

	lengthBuff = bufferUC.size()*sizeof(unsigned char);
	fout.write((char*)&lengthBuff,sizeof(unsigned int));
	fout.write((char*)&(bufferUC[0]), lengthBuff);


	fout.close();
	fout.open(filename, std::ios_base::ate | std::ios_base::app);

	fout << std::endl << "</AppendedData>" << std::endl;
	fout << "</VTKFile>" << std::endl;

	fout.close();
	return true;
}



template <typename PFP>
bool exportVTUCompressed(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position, const char* filename)
{
	if (map.dimension() != 2)
	{
		CGoGNerr << "Surface::Export::exportVTU works only with map of dimension 2"<< CGoGNendl;
		return false;
	}

	typedef typename PFP::MAP MAP;
	typedef typename PFP::VEC3 VEC3;

	// open file
	std::ofstream fout ;
	fout.open(filename, std::ios::out) ;

	if (!fout.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false ;
	}

	VertexAutoAttribute<unsigned int> indices(map,"indices_vert");

	unsigned int count=0;
	for (unsigned int i = position.begin(); i != position.end(); position.next(i))
	{
		indices[i] = count++;
	}

	std::vector<unsigned int> triangles;
	std::vector<unsigned int> quads;
	std::vector<unsigned int> others;
	std::vector<unsigned int> others_begin;
	triangles.reserve(2048);
	quads.reserve(2048);
	others.reserve(2048);
	others_begin.reserve(2048);

	TraversorF<MAP> trav(map) ;
	for(Dart d = trav.begin(); d != trav.end(); d = trav.next())
	{
		unsigned int degree = map.faceDegree(d);
		Dart f=d;
		switch(degree)
		{
			case 3:
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]); f = map.phi1(f);
				triangles.push_back(indices[f]);
				break;
			case 4:
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]); f = map.phi1(f);
				quads.push_back(indices[f]);
				break;

			default:
				others_begin.push_back(others.size());
				do
				{
					others.push_back(indices[f]); f = map.phi1(f);

				} while (f!=d);
				break;
		}
	}
	others_begin.push_back(others.size());

	unsigned int nbtotal = triangles.size()/3 + quads.size()/4 + others_begin.size()-1;

	fout << "<?xml version=\"1.0\"?>" << std::endl;
	fout << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"BigEndian\" compressor=\"vtkZLibDataCompressor\">" << std::endl;
	fout << "<UnstructuredGrid>" <<  std::endl;
	fout << "<Piece NumberOfPoints=\"" << position.nbElements() << "\" NumberOfCells=\""<< nbtotal << "\">" << std::endl;
	fout << "<Points>" << std::endl;
	fout << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" Format=\"binary\">" << std::endl;

	{
		std::vector<VEC3> bufferV3;
		bufferV3.reserve(position.nbElements());
		for (unsigned int i = position.begin(); i != position.end(); position.next(i))
			bufferV3.push_back(position[i]);
		Utils::zlibWriteCompressed((unsigned char*)(&bufferV3[0]),bufferV3.size()*sizeof(VEC3), fout);
	}

	fout << "</DataArray>" << std::endl;
	fout << "</Points>" << std::endl;
	fout << "<Cells>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"connectivity\" Format=\"binary\">" << std::endl;

	std::vector<int> bufferInt;
	bufferInt.reserve(triangles.size()+quads.size()+others.size());

	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		bufferInt.push_back(triangles[i]);
		bufferInt.push_back(triangles[i+1]);
		bufferInt.push_back(triangles[i+2]);
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		bufferInt.push_back(quads[i]);
		bufferInt.push_back(quads[i+1]);
		bufferInt.push_back(quads[i+2]);
		bufferInt.push_back(quads[i+3]);
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int beg = others_begin[i-1];
		unsigned int end = others_begin[i];
		for (unsigned int j=beg; j<end; ++j)
			bufferInt.push_back(others[j]);
	}

	Utils::zlibWriteCompressed((unsigned char*)(&bufferInt[0]),bufferInt.size()*sizeof(int), fout);

	fout << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"offsets\" Format=\"binary\">" ;

	bufferInt.clear();

	unsigned int offset = 0;
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		offset += 3;
		bufferInt.push_back(offset);
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		offset += 4;
		bufferInt.push_back(offset);
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int length = others_begin[i] - others_begin[i-1];
		offset += length;
		bufferInt.push_back(offset);
	}
	Utils::zlibWriteCompressed((unsigned char*)(&bufferInt[0]),bufferInt.size()*sizeof(int), fout);

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"UInt8\" Name=\"types\" Format=\"binary\">";

	for (unsigned int i=0; i<triangles.size(); i+=3)
		bufferInt.push_back(5);

	for (unsigned int i=0; i<quads.size(); i+=4)
		bufferInt.push_back(9);

	for (unsigned int i=1; i<others_begin.size(); ++i)
		bufferInt.push_back(7);

	Utils::zlibWriteCompressed((unsigned char*)(&bufferInt[0]),bufferInt.size()*sizeof(int), fout);

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "</Cells>" << std::endl;
	fout << "</Piece>" << std::endl;
	fout << "</UnstructuredGrid>" << std::endl;
	fout << "</VTKFile>" << std::endl;

	fout.close();
	return true;
}




template <typename PFP>
VTUExporter<PFP>::VTUExporter(typename PFP::MAP& map, const VertexAttribute<typename PFP::VEC3>& position):
	m_map(map),m_position(position),
	nbtotal(0),noPointData(true),noCellData(true),closed(false),binaryMode(false)
{
	if (map.dimension() != 2)
	{
		CGoGNerr << "Surface::Export::exportVTU works only with map of dimension 2"<< CGoGNendl;
	}

}

template <typename PFP>
bool VTUExporter<PFP>::init(const char* filename, bool bin)
{

	// open file
	fout.open(filename, std::ios::out) ;

	if (!fout.good())
	{
		CGoGNerr << "Unable to open file " << filename << CGoGNendl ;
		return false;
	}

	VertexAutoAttribute<unsigned int> indices(m_map,"indices_vert");

	unsigned int count=0;
	for (unsigned int i = m_position.begin(); i != m_position.end(); m_position.next(i))
	{
		indices[i] = count++;
	}

	triangles.reserve(4096);
	quads.reserve(4096);
	others.reserve(4096);
	others_begin.reserve(4096);

	bufferTri.reserve(4096);
	bufferQuad.reserve(4096);
	bufferOther.reserve(4096);

	TraversorF<MAP> trav(m_map) ;
	for(Dart d = trav.begin(); d != trav.end(); d = trav.next())
	{
		unsigned int degree = m_map.faceDegree(d);
		Dart f=d;
		switch(degree)
		{
			case 3:
				bufferTri.push_back(d);
				triangles.push_back(indices[f]); f = m_map.phi1(f);
				triangles.push_back(indices[f]); f = m_map.phi1(f);
				triangles.push_back(indices[f]);
				break;
			case 4:
				bufferQuad.push_back(d);
				quads.push_back(indices[f]); f = m_map.phi1(f);
				quads.push_back(indices[f]); f = m_map.phi1(f);
				quads.push_back(indices[f]); f = m_map.phi1(f);
				quads.push_back(indices[f]);
				break;

			default:
				bufferOther.push_back(d);
				others_begin.push_back(others.size());
				do
				{
					others.push_back(indices[f]); f = m_map.phi1(f);

				} while (f!=d);
				break;
		}
	}
	others_begin.push_back(others.size());

	nbtotal = triangles.size()/3 + quads.size()/4 + others_begin.size()-1;

	fout << "<?xml version=\"1.0\"?>" << std::endl;
	fout << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"BigEndian\">" << std::endl;
	fout << "<UnstructuredGrid>" <<  std::endl;
	fout << "<Piece NumberOfPoints=\"" << m_position.nbElements() << "\" NumberOfCells=\""<< nbtotal << "\">" << std::endl;

	if (bin)
	{
		binaryMode = true;
		f_tempoBin_out.open(filename+"bin_tempo_", std::ios_base::binary);
	}

	return true;
}

template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addVertexAttributeScal(const VertexAttribute<T>& attrib, const std::string& vtkType, const std::string& name)
{
	if (!noCellData)
	{
		CGoGNerr << "VTUExporter<PFP>::addVertexAttribute: endFaceAttributes before adding VertexAttribute"<< CGoGNendl;
		return;
	}

	if (noPointData)
	{
		fout << "<PointData Scalars=\"scalars\">" << std::endl;
		noPointData = false;
	}

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = attrib.begin(); i != attrib.end(); attrib.next(i))
		fout << attrib[i] << std::endl;

	fout << "</DataArray>" << std::endl;

}

template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addVertexAttributeVect(const VertexAttribute<T>& attrib, const std::string& vtkType,  unsigned int nbComp, const std::string& name)
{
	if (!noCellData)
	{
		CGoGNerr << "VTUExporter<PFP>::addVertexAttribute: endFaceAttributes before adding VertexAttribute"<< CGoGNendl;
		return;
	}

	if (noPointData)
	{
		fout << "<PointData Scalars=\"scalars\">" << std::endl;
		noPointData = false;
	}

	if (nbComp==0)
		nbComp = sizeof(T)/(unsigned int)(2*(vtkType[vtkType.size()-1]-'0')); // Float32 -> 2*2=4 bytes Int64 -> 8 bytes

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = attrib.begin(); i != attrib.end(); attrib.next(i))
	{
		const T& a = attrib[i];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}
	fout << "</DataArray>" << std::endl;
}



template <typename PFP>
void VTUExporter<PFP>::endVertexAttributes()
{
	if (!noPointData)
		fout << "</PointData>" << std::endl;

	noPointData = true;
}


template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addFaceAttributeScal(const FaceAttribute<T>& attrib, const std::string& vtkType, const std::string& name)
{
	if (!noPointData)
	{
		CGoGNerr << "VTUExporter<PFP>::addFaceAttribute: endVertexAttributes before adding FaceAttribute"<< CGoGNendl;
		return;
	}

	if (noCellData)
	{
		fout << "<CellData Scalars=\"scalars\">" << std::endl;
		noCellData = false;
	}

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" Format=\"ascii\">" << std::endl;


	for (typename std::vector<Dart>::iterator it = bufferTri.begin(); it != bufferTri.end(); ++it)
		fout << attrib[*it] << std::endl;
	for (typename std::vector<Dart>::iterator it = bufferQuad.begin(); it != bufferQuad.end(); ++it)
		fout << attrib[*it] << std::endl;
	for (typename std::vector<Dart>::iterator it = bufferOther.begin(); it != bufferOther.end(); ++it)
		fout << attrib[*it] << std::endl;
	fout << "</DataArray>" << std::endl;

}


template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addFaceAttributeVect(const FaceAttribute<T>& attrib, const std::string& vtkType, unsigned int nbComp, const std::string& name)
{
	if (!noPointData)
	{
		CGoGNerr << "VTUExporter<PFP>::addFaceAttribute: endVertexAttributes before adding FaceAttribute"<< CGoGNendl;
		return;
	}

	if (noCellData)
	{
		fout << "<CellData Scalars=\"scalars\">" << std::endl;
		noCellData = false;
	}

	if (nbComp==0)
		nbComp = sizeof(T)/(unsigned int)(2*(vtkType[vtkType.size()-1]-'0')); // Float32 -> 2*2=4 bytes Int64 -> 8 bytes

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;

	for (typename std::vector<Dart>::iterator it = bufferTri.begin(); it != bufferTri.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}

	for (typename std::vector<Dart>::iterator it = bufferQuad.begin(); it != bufferQuad.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}

	for (typename std::vector<Dart>::iterator it = bufferOther.begin(); it != bufferOther.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}
	fout << "    </DataArray>" << std::endl;

}

template <typename PFP>
void VTUExporter<PFP>::endFaceAttributes()
{
	if (!noCellData)
		fout << "</CellData>" << std::endl;

	noCellData = true;
}


template <typename PFP>
bool VTUExporter<PFP>::close()
{
	if (!noPointData)
		endVertexAttributes();

	if (!noCellData)
		endFaceAttributes();

	fout << "<Points>" << std::endl;
	fout << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = m_position.begin(); i != m_position.end(); m_position.next(i))
	{
		const VEC3& P = m_position[i];
		fout << P[0]<< " " << P[1]<< " " << P[2] << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "</Points>" << std::endl;
	fout << "<Cells>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"connectivity\" Format=\"ascii\">" << std::endl;

	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		fout << triangles[i]   << " " << triangles[i+1] << " " << triangles[i+2] << std::endl;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		fout << quads[i]   << " " << quads[i+1] << " " << quads[i+2] << " " << quads[i+3]<< std::endl;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int beg = others_begin[i-1];
		unsigned int end = others_begin[i];
		for (unsigned int j=beg; j<end; ++j)
		{
			fout <<  others[j] << " ";
		}
		fout << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"offsets\" Format=\"ascii\">" ;

	unsigned int offset = 0;
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		offset += 3;
		if (i%60 ==0)
			fout << std::endl;
		fout << " " << offset;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		offset += 4;
		if (i%80 ==0)
			fout << std::endl;
		fout << " "<< offset;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int length = others_begin[i] - others_begin[i-1];
		offset += length;
		if (i%20 ==0)
			fout << std::endl;
		fout << " "<< offset;
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"UInt8\" Name=\"types\" Format=\"ascii\">";
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		if (i%60 ==0)
			fout << std::endl;
		fout << " 5";
	}
	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		if (i%80 ==0)
			fout << std::endl;
		fout << " 9";
	}
	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		if (i%20 ==0)
			fout << std::endl;
		fout << " 7";
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "</Cells>" << std::endl;
	fout << "</Piece>" << std::endl;
	fout << "</UnstructuredGrid>" << std::endl;
	fout << "</VTKFile>" << std::endl;

	fout.close();
	closed=true;
	return true;
}



// BINARY VERSION

template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addBinaryVertexAttributeScal(const VertexAttribute<T>& attrib, const std::string& vtkType, const std::string& name)
{
	if (!noCellData)
	{
		CGoGNerr << "VTUExporter<PFP>::addVertexAttribute: endFaceAttributes before adding VertexAttribute"<< CGoGNendl;
		return;
	}

	if (noPointData)
	{
		fout << "<PointData Scalars=\"scalars\">" << std::endl;
		noPointData = false;
	}

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = attrib.begin(); i != attrib.end(); attrib.next(i))
		fout << attrib[i] << std::endl;

	fout << "</DataArray>" << std::endl;

}

template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addBinaryVertexAttributeVect(const VertexAttribute<T>& attrib, const std::string& vtkType,  unsigned int nbComp, const std::string& name)
{
	if (!noCellData)
	{
		CGoGNerr << "VTUExporter<PFP>::addVertexAttribute: endFaceAttributes before adding VertexAttribute"<< CGoGNendl;
		return;
	}

	if (noPointData)
	{
		fout << "<PointData Scalars=\"scalars\">" << std::endl;
		noPointData = false;
	}

	if (nbComp==0)
		nbComp = sizeof(T)/(unsigned int)(2*(vtkType[vtkType.size()-1]-'0')); // Float32 -> 2*2=4 bytes Int64 -> 8 bytes

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = attrib.begin(); i != attrib.end(); attrib.next(i))
	{
		const T& a = attrib[i];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}
	fout << "</DataArray>" << std::endl;
}



template <typename PFP>
void VTUExporter<PFP>::endBinaryVertexAttributes()
{
	if (!noPointData)
		fout << "</PointData>" << std::endl;

	noPointData = true;
}


template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addBinaryFaceAttributeScal(const FaceAttribute<T>& attrib, const std::string& vtkType, const std::string& name)
{
	if (!noPointData)
	{
		CGoGNerr << "VTUExporter<PFP>::addFaceAttribute: endVertexAttributes before adding FaceAttribute"<< CGoGNendl;
		return;
	}

	if (noCellData)
	{
		fout << "<CellData Scalars=\"scalars\">" << std::endl;
		noCellData = false;
	}

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" Format=\"ascii\">" << std::endl;


	for (typename std::vector<Dart>::iterator it = bufferTri.begin(); it != bufferTri.end(); ++it)
		fout << attrib[*it] << std::endl;
	for (typename std::vector<Dart>::iterator it = bufferQuad.begin(); it != bufferQuad.end(); ++it)
		fout << attrib[*it] << std::endl;
	for (typename std::vector<Dart>::iterator it = bufferOther.begin(); it != bufferOther.end(); ++it)
		fout << attrib[*it] << std::endl;
	fout << "</DataArray>" << std::endl;

}


template <typename PFP>
template<typename T>
void VTUExporter<PFP>::addBinaryFaceAttributeVect(const FaceAttribute<T>& attrib, const std::string& vtkType, unsigned int nbComp, const std::string& name)
{
	if (!noPointData)
	{
		CGoGNerr << "VTUExporter<PFP>::addFaceAttribute: endVertexAttributes before adding FaceAttribute"<< CGoGNendl;
		return;
	}

	if (noCellData)
	{
		fout << "<CellData Scalars=\"scalars\">" << std::endl;
		noCellData = false;
	}

	if (nbComp==0)
		nbComp = sizeof(T)/(unsigned int)(2*(vtkType[vtkType.size()-1]-'0')); // Float32 -> 2*2=4 bytes Int64 -> 8 bytes

	if (name.size() != 0)
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<name<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;
	else
		fout << "<DataArray type=\""<< vtkType <<"\" Name=\""<<attrib.name()<<"\" NumberOfComponents=\""<< nbComp <<"\" Format=\"ascii\">" << std::endl;

	for (typename std::vector<Dart>::iterator it = bufferTri.begin(); it != bufferTri.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}

	for (typename std::vector<Dart>::iterator it = bufferQuad.begin(); it != bufferQuad.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}

	for (typename std::vector<Dart>::iterator it = bufferOther.begin(); it != bufferOther.end(); ++it)
	{
		const T& a = attrib[*it];
		for (unsigned int j=0;j<nbComp;++j)
			fout << a[j]<< " ";
		fout << std::endl;
	}
	fout << "    </DataArray>" << std::endl;

}

template <typename PFP>
void VTUExporter<PFP>::endBinaryFaceAttributes()
{
	if (!noCellData)
		fout << "</CellData>" << std::endl;

	noCellData = true;
}


template <typename PFP>
bool VTUExporter<PFP>::binaryClose()
{
	if (!noPointData)
		endVertexAttributes();

	if (!noCellData)
		endFaceAttributes();

	fout << "<Points>" << std::endl;
	fout << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" Format=\"ascii\">" << std::endl;

	for (unsigned int i = m_position.begin(); i != m_position.end(); m_position.next(i))
	{
		const VEC3& P = m_position[i];
		fout << P[0]<< " " << P[1]<< " " << P[2] << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "</Points>" << std::endl;
	fout << "<Cells>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"connectivity\" Format=\"ascii\">" << std::endl;

	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		fout << triangles[i]   << " " << triangles[i+1] << " " << triangles[i+2] << std::endl;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		fout << quads[i]   << " " << quads[i+1] << " " << quads[i+2] << " " << quads[i+3]<< std::endl;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int beg = others_begin[i-1];
		unsigned int end = others_begin[i];
		for (unsigned int j=beg; j<end; ++j)
		{
			fout <<  others[j] << " ";
		}
		fout << std::endl;
	}

	fout << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"Int32\" Name=\"offsets\" Format=\"ascii\">" ;

	unsigned int offset = 0;
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		offset += 3;
		if (i%60 ==0)
			fout << std::endl;
		fout << " " << offset;
	}

	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		offset += 4;
		if (i%80 ==0)
			fout << std::endl;
		fout << " "<< offset;
	}

	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		unsigned int length = others_begin[i] - others_begin[i-1];
		offset += length;
		if (i%20 ==0)
			fout << std::endl;
		fout << " "<< offset;
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "<DataArray type=\"UInt8\" Name=\"types\" Format=\"ascii\">";
	for (unsigned int i=0; i<triangles.size(); i+=3)
	{
		if (i%60 ==0)
			fout << std::endl;
		fout << " 5";
	}
	for (unsigned int i=0; i<quads.size(); i+=4)
	{
		if (i%80 ==0)
			fout << std::endl;
		fout << " 9";
	}
	for (unsigned int i=1; i<others_begin.size(); ++i)
	{
		if (i%20 ==0)
			fout << std::endl;
		fout << " 7";
	}

	fout << std::endl << "</DataArray>" << std::endl;
	fout << "</Cells>" << std::endl;
	fout << "</Piece>" << std::endl;
	fout << "</UnstructuredGrid>" << std::endl;
	fout << "</VTKFile>" << std::endl;

	fout.close();
	closed=true;
	return true;
}




template <typename PFP>
VTUExporter<PFP>::~VTUExporter()
{
	if (!closed)
		close();
	closed = true;
}


} // namespace Export

}

} // namespace Algo

} // namespace CGoGN
